<!DOCTYPE html>
<!--
Copyright 2015-2016 Robert Schroll

This file is part of Juno and is distributed under the terms of the
BSD license. See the file LICENSE for full details.
-->
<html>
  <head>
    <meta charset="UTF-8">
    <title>Juno</title>
    <script src="riot.js"></script>
    <style>
      body {
        margin: 0;
        font: menu;
        -webkit-user-select: none;
        cursor: default;
      }
      
      #main {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: flex;
        align-items: stretch;
      }
      .left-pane {
        position: relative;
        width: 200px;
      }
      .right-pane {
        position: relative;
        flex-grow: 1;
      }
      .separator {
        width: 4px;
        background-color: #ddd;
        cursor: col-resize;
      }
      .separator:hover {
        background-color: #ccc;
      }
      .separator:active {
        background-color: #aaa;
      }
    </style>
    <link rel="stylesheet" href="font-awesome/css/font-awesome.css" />
  </head>
  <body>
    <div id="main" class="panes">
      <div class="left-pane">
        <file-list></file-list>
      </div>
      <span class="separator"></span>
      <div class="right-pane">
        <notebook-tabs></notebook-tabs>
      </div>
    </div>
    <login-view></login-view>
    <connect-page></connect-page>
    <script src="tags.js"></script>
    <script>
      'use strict';
      var list = riot.mount("file-list")[0];
      var tabs = riot.mount("notebook-tabs")[0];
      var login = riot.mount("login-view")[0];
      var connect = riot.mount("connect-page")[0];
      
      function saveAndOpen(data, fn) {
        let path = require("path");
        let fs = require("fs");
        let filename = path.parse(fn);
        let fns = path.join("/tmp", filename.base);
        let i = 0;
        while (fs.existsSync(fns)) {
          fns = path.join("/tmp", filename.name + i + filename.ext);
          i += 1;
        }
        fs.writeFileSync(fns, data);
        require("electron").shell.openItem(fns);
      }
      
      function download(url) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url);
        xhr.addEventListener("load", function (event) {
          if (xhr.status != 200) {
            console.log("Unexpected status (" + xhr.status + ") when downloading " + url);
            return;
          }
          let fn = xhr.getResponseHeader("Content-Disposition").match(/"(.*)"/)[1];
          if (!fn) {
            console.log("Error getting filename for " + url);
            return;
          }
          saveAndOpen(xhr.responseText, fn);
        });
        xhr.addEventListener("error", function (event) {
          console.log("Error downloading " + url);
        });
        xhr.send();
      }
      
      function openData(dataUrl) {
        let data = dataUrl.split(";")[1].split(",");
        let buf = new Buffer(data[1], data[0]);
        saveAndOpen(buf, 'jupyter-data');
      }
      
      riot.host = undefined;
      riot.openUrl = function (url) {
        if (riot.host === undefined)
          throw "Host hasn't been set."
        
        var downloadSuffix = "?download=true";
        if (url.slice(-downloadSuffix.length) == downloadSuffix)
          return download(url);
        
        if (url.slice(0, riot.host.length) == riot.host)
          return tabs.openNotebook(url);
        if (url.slice(0, 4) == "data")
          return openData(url);
        require("electron").shell.openExternal(url);
      }
      riot.login = function (url, callback) {
        login.login(url, callback);
      }
      riot.newFile = function (type, directory, kernel_name) {
        list.newFile(type, directory, kernel_name);
      }
      riot.formatPath = function (path) {
        let home = require("electron").remote.app.getPath("home");
        if (path.slice(0, home.length) == home)
          return "~" + path.slice(home.length, path.length);
        return path;
      }
      
      var ipcRenderer = require("electron").ipcRenderer;
      ipcRenderer.on('set-host', function (event, host, path) {
        riot.host = host;
        if (riot.host) {
          list.loadFiles("", riot.host, path);
          connect.close();
        } else {
          connect.open();
        }
      });
      ipcRenderer.on('toggle-dev-tools', function (event, message) {
        tabs.toggleDevTools();
      });
      
      window.onbeforeunload = function (event) {
        event.returnValue = tabs.closeAll();
      }
      
      function saveWindowGeometry() {
        let geom = {
          "width": window.outerWidth,
          "height": window.outerHeight,
          "mainPane": document.querySelector("#main .left-pane").clientWidth
        };
        localStorage.windowGeometry = JSON.stringify(geom);
      }
      
      function loadWindowGeometry() {
        let geom = null;
        try {
          geom = JSON.parse(localStorage.windowGeometry);
        } catch (e) {
          return;
        }
        if (geom.width && geom.height)
          window.resizeTo(geom.width, geom.height);
        if (geom.mainPane)
          document.querySelector("#main .left-pane").style.width = geom.mainPane + "px";
      }
      
      function setPaneDrag(pane) {
        let lp = pane.querySelector(".left-pane");
        let sep = pane.querySelector(".separator");
        let dragStartX = 0;
        let widthStart = 0;
        
        function mouseUpListener(event) {
          document.body.removeEventListener('mouseup', mouseUpListener, true);
          document.body.removeEventListener('mousemove', mouseMoveListener, true);
          saveWindowGeometry();
        }
        
        function mouseMoveListener(event) {
          let dx = event.pageX - dragStartX;
          lp.style.width = widthStart + dx + "px";
        }
        
        sep.addEventListener("mousedown", function (event) {
          dragStartX = event.pageX;
          widthStart = lp.clientWidth;
          document.body.addEventListener("mouseup", mouseUpListener, true);
          document.body.addEventListener("mousemove", mouseMoveListener, true);
        });
      }
      
      document.addEventListener("DOMContentLoaded", function (event) {
        let panes = document.querySelectorAll(".panes");
        for (let i=0; i<panes.length; i++)
          setPaneDrag(panes[i]);
        loadWindowGeometry();
        
        let resizeTimeout;
        window.addEventListener("resize", function () {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(function () {
            resizeTimeout = null;
            saveWindowGeometry();
          }, 250);
        });
      });
    </script>
  </body>
</html>
